{
  "name": "nconf",
  "description": "Hierarchical node.js configuration with files, environment variables, command-line arguments, and atomic object merging.",
  "version": "0.4.6",
  "author": {
    "name": "Charlie Robbins",
    "email": "charlie.robbins@gmail.com"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/flatiron/nconf.git"
  },
  "keywords": [
    "configuration",
    "key value store",
    "plugabble"
  ],
  "dependencies": {
    "async": "0.1.x",
    "ini": "1.x.x",
    "optimist": "0.2.x",
    "pkginfo": "0.2.x"
  },
  "devDependencies": {
    "vows": "0.5.x >=0.5.11"
  },
  "main": "./lib/nconf",
  "scripts": {
    "test": "vows test/*-test.js --spec"
  },
  "engines": {
    "node": ">= 0.4.0"
  },
  "readme": "# nconf [![Build Status](https://secure.travis-ci.org/flatiron/nconf.png)](http://travis-ci.org/flatiron/nconf)\n\nHierarchical node.js configuration with files, environment variables, command-line arguments, and atomic object merging.\n\n## Installation\n\n### Installing npm (node package manager)\n```\n  curl http://npmjs.org/install.sh | sh\n```\n\n### Installing nconf\n```\n  [sudo] npm install nconf\n```\n\n## Getting started \nUsing nconf is easy; it is designed to be a simple key-value store with support for both local and remote storage. Keys are namespaced and delimited by `:`. Lets dive right into sample usage:\n\n``` js\n  var fs    = require('fs'),\n      nconf = require('nconf');\n  \n  //\n  // Setup nconf to use the 'file' store and set a couple of values;\n  //\n  nconf.add('file', { file: 'path/to/your/config.json' });\n  nconf.set('database:host', '127.0.0.1');\n  nconf.set('database:port', 5984);\n  \n  //\n  // Get the entire database object from nconf. This will output\n  // { host: '127.0.0.1', port: 5984 }\n  //\n  console.dir(nconf.get('database')); \n  \n  //\n  // Save the configuration object to disk\n  //\n  nconf.save(function (err) {\n    fs.readFile('path/to/your/config.json', function (err, data) {\n      console.dir(JSON.parse(data.toString()))\n    });\n  });\n```\n\n## Hierarchical configuration\n\nConfiguration management can get complicated very quickly for even trivial applications running in production. `nconf` addresses this problem by enabling you to setup a hierarchy for different sources of configuration with some sane defaults (in-order):\n\n  1. Manually set overrides\n  2. Command-line arguments\n  3. Environment variables\n  4. Any additional user stores (in the order they were added) \n\nThe top-level of `nconf` is an instance of the `nconf.Provider` abstracts this all for you into a simple API.\n\n### nconf.add(name, options)\nAdds a new store with the specified `name` and `options`. If `options.type` is not set, then `name` will be used instead:\n\n``` js\n  nconf.add('global', { type: 'file', file: '/path/to/globalconf.json' });\n  nconf.add('userconf', { type: 'file', file: '/path/to/userconf.json' });\n```\n\n### nconf.use(name, options) \nSimilar to `nconf.add`, except that it can replace an existing store if new options are provided\n\n``` js\n  //\n  // Load a file store onto nconf with the specified settings\n  //\n  nconf.use('file', { file: '/path/to/some/config-file.json' });\n  \n  //\n  // Replace the file store with new settings\n  //\n  nconf.use('file', { file: 'path/to/a-new/config-file.json' });\n```\n\n### nconf.remove(name)\nRemoves the store with the specified `name.` The configuration stored at that level will no longer be used for lookup(s).\n\n``` js\n  nconf.remove('file');\n```\n\n## Working with Configuration\n`nconf` will traverse the set of stores that you have setup in-order to ensure that the value in the store of the highest priority is used. For example to setup following sample configuration:\n\n1. Command-line arguments\n2. Environment variables\n3. User configuration\n3. Global configuration\n\n``` js\n  var nconf = require('nconf');\n  \n  //\n  // Read in command-line arugments and environment variables\n  //\n  nconf.argv = nconf.env = true;\n  \n  //\n  // Setup the `user` store followed by the `global` store. Note that\n  // order is significant in these operations.\n  //\n  nconf.add('user', { file: 'path/to/user-config.json' });\n  nconf.add('global', { file: 'path/to/global-config.json' })\n```\n\n## Storage Engines\n\n### Memory\nA simple in-memory storage engine that stores a nested JSON representation of the configuration. To use this engine, just call `.use()` with the appropriate arguments. All calls to `.get()`, `.set()`, `.clear()`, `.reset()` methods are synchronous since we are only dealing with an in-memory object.\n\n``` js \n  nconf.use('memory');\n```\n\n### System\nBased on the Memory store, but exposes hooks into manual overrides, command-line arguments, and environment variables (in that order of priority). Every instance of `nconf.Provider`, including the top-level `nconf` object itself already has a `System` store at the top-level, so configuring it only requires setting properties\n\n``` js\n  //\n  // `nconf.get(awesome)` will always return true regardless of \n  // command-line arguments or environment variables.\n  //\n  nconf.overrides = { awesome: true };\n  \n  //\n  // Can also be an object literal to pass to `optimist`.\n  //\n  nconf.argv = true;\n  \n  //\n  // Can also be an array of variable names to restrict loading to.\n  //\n  nconf.env = true;\n```\n\n### File\nBased on the Memory store, but provides additional methods `.save()` and `.load()` which allow you to read your configuration to and from file. As with the Memory store, all method calls are synchronous with the exception of `.save()` and `.load()` which take callback functions. It is important to note that setting keys in the File engine will not be persisted to disk until a call to `.save()` is made.\n\n``` js\n  nconf.use('file', { file: 'path/to/your/config.json' });\n```\n\nThe file store is also extensible for multiple file formats, defaulting to `JSON`. To use a custom format, simply pass a format object to the `.use()` method. This object must have `.parse()` and `.stringify()` methods just like the native `JSON` object.\n\n### Redis\nThere is a separate Redis-based store available through [nconf-redis][0]. To install and use this store simply:\n\n``` bash\n  $ npm install nconf\n  $ npm install nconf-redis\n```\n\nOnce installing both `nconf` and `nconf-redis`, you must require both modules to use the Redis store:\n\n``` js\n  var nconf = require('nconf');\n  \n  //\n  // Requiring `nconf-redis` will extend the `nconf`\n  // module.\n  //\n  require('nconf-redis');\n  \n  nconf.use('redis', { host: 'localhost', port: 6379, ttl: 60 * 60 * 1000 });\n```\n\n## More Documentation\nThere is more documentation available through docco. I haven't gotten around to making a gh-pages branch so in the meantime if you clone the repository you can view the docs:\n\n```\n  open docs/nconf.html\n```\n\n## Run Tests\nTests are written in vows and give complete coverage of all APIs and storage engines.\n\n``` bash\n  $ npm test\n```\n\n#### Author: [Charlie Robbins](http://nodejitsu.com)\n\n[0]: http://github.com/indexzero/nconf\n",
  "_id": "nconf@0.4.6",
  "_from": "nconf@0.4.x"
}
